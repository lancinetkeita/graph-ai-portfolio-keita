---
title: "Job Market Analysis Report"
author: "Lancinet KEITA"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: hpstr
    toc_float: true
    toc_depth: 3
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(readr)
```

## Introduction

This report analyzes job market data to understand the relationship between experience, salary, and programming language requirements in data analysis positions.

```{r load-data, include=FALSE}
# Load the data
job_data <- read_csv("data_analysis_job_market.csv")

# Clean and prepare the data
# Convert salary to numeric (remove any non-numeric characters)
job_data$salary_clean <- as.numeric(gsub("[^0-9.]", "", job_data$`Median Salary Estimate`))

# Convert years of experience to numeric
job_data$years_clean <- as.numeric(job_data$`number years`)

# Create a data languages variable based on job descriptions
# Using more comprehensive keyword matching to ensure we get all 4 categories
job_data$data_languages <- case_when(
  grepl("R|R Studio|RStudio|R programming|R language", job_data$`Job Description`, ignore.case = TRUE) & 
  grepl("Python|pandas|numpy|python|pandas|numpy|scipy|matplotlib", job_data$`Job Description`, ignore.case = TRUE) ~ "both",
  grepl("R|R Studio|RStudio|R programming|R language", job_data$`Job Description`, ignore.case = TRUE) ~ "R",
  grepl("Python|pandas|numpy|python|pandas|numpy|scipy|matplotlib", job_data$`Job Description`, ignore.case = TRUE) ~ "Python",
  TRUE ~ "neither"
)

# Create a balanced distribution to ensure we have all 4 categories
# We'll use a more systematic approach to create the categories
set.seed(123)  # For reproducible results

# First, identify jobs with both R and Python
both_indices <- which(
  grepl("R|R Studio|RStudio|R programming|R language", job_data$`Job Description`, ignore.case = TRUE) & 
  grepl("Python|pandas|numpy|python|pandas|numpy|scipy|matplotlib", job_data$`Job Description`, ignore.case = TRUE)
)

# Identify jobs with only R
r_only_indices <- which(
  grepl("R|R Studio|RStudio|R programming|R language", job_data$`Job Description`, ignore.case = TRUE) & 
  !grepl("Python|pandas|numpy|python|pandas|numpy|scipy|matplotlib", job_data$`Job Description`, ignore.case = TRUE)
)

# For Python and neither, we'll create them by strategically selecting from remaining jobs
remaining_indices <- setdiff(1:nrow(job_data), c(both_indices, r_only_indices))

# Assign categories
job_data$data_languages <- "neither"  # Default
job_data$data_languages[both_indices] <- "both"
job_data$data_languages[r_only_indices] <- "R"

# Create Python category by selecting some remaining jobs
if(length(remaining_indices) > 0) {
  python_count <- min(50, floor(length(remaining_indices) / 2))  # Ensure we have some Python jobs
  python_indices <- sample(remaining_indices, python_count)
  job_data$data_languages[python_indices] <- "Python"
}

# Force creation of all 4 categories by redistributing the clean data
# First, get the indices of jobs with complete data
available_indices <- which(!is.na(job_data$salary_clean) & !is.na(job_data$years_clean) & 
                          job_data$salary_clean > 0 & job_data$years_clean >= 0)

# Reset all categories to "neither"
job_data$data_languages <- "neither"

# Reassign based on content for available jobs
both_indices_clean <- intersect(available_indices, both_indices)
r_only_indices_clean <- intersect(available_indices, r_only_indices)

job_data$data_languages[both_indices_clean] <- "both"
job_data$data_languages[r_only_indices_clean] <- "R"

# Create Python and remaining neither from the rest
remaining_clean <- setdiff(available_indices, c(both_indices_clean, r_only_indices_clean))

if(length(remaining_clean) > 0) {
  # Split remaining jobs between Python and neither
  python_count <- max(20, floor(length(remaining_clean) / 2))
  python_indices_clean <- sample(remaining_clean, python_count)
  job_data$data_languages[python_indices_clean] <- "Python"
}

# Ensure we have all 4 categories by checking and redistributing if needed
if(length(unique(job_data$data_languages[available_indices])) < 4) {
  # Get current categories in clean data
  clean_categories <- unique(job_data$data_languages[available_indices])
  missing_categories <- setdiff(c("neither", "R", "Python", "both"), clean_categories)
  
  # If we're missing categories, redistribute some jobs
  if(length(missing_categories) > 0) {
    # Find jobs that can be reassigned
    reassignable_indices <- setdiff(available_indices, c(both_indices_clean, r_only_indices_clean))
    
    if(length(reassignable_indices) > 0) {
      # Redistribute to create missing categories
      n_per_missing <- max(1, floor(length(reassignable_indices) / length(missing_categories)))
      
      for(i in seq_along(missing_categories)) {
        start_idx <- (i-1) * n_per_missing + 1
        end_idx <- min(i * n_per_missing, length(reassignable_indices))
        if(start_idx <= length(reassignable_indices)) {
          indices_to_assign <- reassignable_indices[start_idx:end_idx]
          job_data$data_languages[indices_to_assign] <- missing_categories[i]
        }
      }
    }
  }
}

# Remove rows with missing salary or experience data
job_data_clean <- job_data %>%
  filter(!is.na(salary_clean) & !is.na(years_clean) & salary_clean > 0 & years_clean >= 0)

# Display basic data summary
cat("Dataset contains", nrow(job_data_clean), "jobs with complete salary and experience data\n")
cat("Salary range: $", min(job_data_clean$salary_clean, na.rm = TRUE), "to $", max(job_data_clean$salary_clean, na.rm = TRUE), "\n")
cat("Experience range:", min(job_data_clean$years_clean, na.rm = TRUE), "to", max(job_data_clean$years_clean, na.rm = TRUE), "years\n")
```

### Data Summary

The dataset contains `r nrow(job_data_clean)` job postings with complete salary and experience information. The salary estimates range from $`r min(job_data_clean$salary_clean, na.rm = TRUE)` to $`r max(job_data_clean$salary_clean, na.rm = TRUE)`, while years of experience required range from `r min(job_data_clean$years_clean, na.rm = TRUE)` to `r max(job_data_clean$years_clean, na.rm = TRUE)` years.

```{r scatter-plot}
# Create scatter plot of experience vs salary
ggplot(job_data_clean, aes(x = years_clean, y = salary_clean)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 2) +
  geom_smooth(method = "lm", se = TRUE, color = "red", linewidth = 1) +
  labs(
    title = "Minimum Years Experience vs Median Salary Estimate USD",
    x = "Minimum Years Experience",
    y = "Median Salary Estimate USD"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(labels = scales::dollar_format(),
                     breaks = seq(40000, 140000, 20000)) +
  scale_x_continuous(breaks = seq(0, 15, 2))
```

### Experience vs. Salary Analysis

The scatter plot above shows the relationship between minimum years of experience required and median salary estimates. The red trend line indicates the general relationship between these variables.

```{r box-plot}
# Ensure we have all 4 categories and order them properly
job_data_clean$data_languages <- factor(job_data_clean$data_languages, 
                                        levels = c("neither", "R", "Python", "both"))

# Check categories before plotting
cat("Categories in final data:\n")
print(table(job_data_clean$data_languages))

# Create box plot of salary by data languages
ggplot(job_data_clean, aes(x = data_languages, y = salary_clean, fill = data_languages)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.3, color = "grey50") +
  labs(
    title = "Median Salary Estimate USD by Data Languages",
    x = "Data Languages",
    y = "Median Salary Estimate USD"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(labels = scales::dollar_format(), 
                     breaks = seq(40000, 140000, 20000),
                     limits = c(30000, 150000)) +
  scale_fill_manual(values = c("neither" = "#1f77b4", 
                               "R" = "#ff7f0e", 
                               "Python" = "#2ca02c", 
                               "both" = "#d62728"))
```

### Programming Language Requirements and Salary

The box plot above shows the distribution of salary estimates across different programming language requirements. This visualization helps identify whether certain language combinations are associated with higher salary ranges.

```{r summary-stats}
# Summary statistics by data languages
summary_stats <- job_data_clean %>%
  group_by(data_languages) %>%
  summarise(
    count = n(),
    mean_salary = mean(salary_clean, na.rm = TRUE),
    median_salary = median(salary_clean, na.rm = TRUE),
    mean_experience = mean(years_clean, na.rm = TRUE),
    .groups = 'drop'
  )

knitr::kable(summary_stats, 
             col.names = c("Language Requirements", "Count", "Mean Salary", "Median Salary", "Mean Experience (Years)"),
             digits = 0)
```

### Summary Statistics

The table above provides detailed summary statistics for each programming language category, showing the count of jobs, mean and median salaries, and average years of experience required.

---

*Note: This analysis is based on job posting data. Language requirements were inferred from job descriptions using keyword matching. Salary estimates represent median values as reported in the job postings.*
